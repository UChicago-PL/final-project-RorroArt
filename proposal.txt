We propose to build a small compiler toolchain in Haskell for the VLIW+SIMD "accelerator" described in Anthropicâ€™s original performance take-home (https://github.com/anthropics/original_performance_takehome).

The simulator exposes multiple execution paths including a scalar ALU, vector ALU, load, store, etc., and a SIMD width of 8 lanes.

We are provided a baseline program that is intentionally under-optimized: it emits one operation per cycle and leaves most of the machine's parallelism unused.

Our project will generate correct programs for this ISA and then optimize with compiler techniques: instruction selection/lowering, dependence analysis, VLIW bundling (packing independent ops into the same cycle), and selective vectorization. The end goal is to demonstrate measurable cycle-count improvements on the provided harness while maintaining correctness against the reference implementation.

We believe this to be a good fit for the class since a lot of the compiler techniques are very neatly expressible in Haskell: dependence analysis is a graph problem, ISA and IR can be ADTs, the simultor could be monadic (either through the State monad or something proprietary). Compilers are, in general, very nice to write in functional languages.

First priority:
* Model the ISA ADT and build a program emitter that can output a runnable program for Anthropic's Python simulator.
* Ensure that we can emit the baseline program, and that it runs correctly by check correctness by comparing outputs with the reference simulator.

Next step:
* Implement a dependence analysis VLIW scheduler (e.g., greedy scheduler)
* Add basic optimizations for scheduling: common subexpression elimination/constant hoisting, dead-code elimination, and simple register allocation. Note that in Anthropic's simulator this is allocation on a scratch buffer, not quite reg alloc, but they're conceptually similar.

Challenge:
* SIMD vectorization, using vector ALU ops and gathers properly.
* Modulo scheduling and other advanced scheduling techniques? We have been reading about optimal pipelining and scheduling, this is a very interesting problem (https://arxiv.org/pdf/2512.18134)


We'd also like to build nice pretty-printing and visualization tools that will help us build intuition about this problem. It is unclear what sort of tools we will build, but that will become clear as we begin work.
